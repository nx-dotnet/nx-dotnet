"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[550],{409:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=t(1085),r=t(2247);const i={},s="Handling Solution Files",l={id:"core/guides/handling-solutions",title:"Handling Solution Files",description:"Workspace Level",source:"@site/../../docs/core/guides/handling-solutions.md",sourceDirName:"core/guides",slug:"/core/guides/handling-solutions",permalink:"/core/guides/handling-solutions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/core/"},next:{title:"Nx Incremental Builds",permalink:"/core/guides/incremental-builds"}},a={},c=[{value:"Workspace Level",id:"workspace-level",level:2},{value:"Subgraph Solutions",id:"subgraph-solutions",level:2},{value:"Separate solution files",id:"separate-solution-files",level:3},{value:"Solution filters",id:"solution-filters",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.RP)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"handling-solution-files",children:"Handling Solution Files"}),"\n",(0,o.jsx)(n.h2,{id:"workspace-level",children:"Workspace Level"}),"\n",(0,o.jsxs)(n.p,{children:["As of v1.7.0, ",(0,o.jsx)(n.code,{children:"nx-dotnet"})," supports adding projects to a workspace level solution file automatically. When generating an app, lib, or test project you can pass ",(0,o.jsx)(n.code,{children:"--solutionFile"})," to add the project to the default solution at the workspace root. Alternatively, you can pass ",(0,o.jsx)(n.code,{children:"--solutionFile {path/to/sln}"})," to add the project to a custom solution file. This should look something like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npx nx g @nx-dotnet/core:app my-api --template webapi --solutionFile MyCompany.sln\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To add projects to a solution file by default, you can set the generator defaults in ",(0,o.jsx)(n.a,{href:"https://nx.dev/l/a/core-concepts/configuration#nxjson",children:"nx.json"})," as below:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  // ... more nx.json configuration\n  "generators": {\n    // ... other default configurations\n    "@nx-dotnet/core:application": {\n      "solutionFile": true\n    },\n    // ... other default configurations\n    "@nx-dotnet/core:library": {\n      "solutionFile": "my-sln.sln"\n    }\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note that the generator names in ",(0,o.jsx)(n.code,{children:"nx.json"})," must be the full name. Alias's like ",(0,o.jsx)(n.code,{children:"app"}),", ",(0,o.jsx)(n.code,{children:"lib"})," and so on will not be recognized. Aliases that work on the command line for options, like --solution, are also not supported currently."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"subgraph-solutions",children:"Subgraph Solutions"}),"\n",(0,o.jsxs)(n.p,{children:["In a large monorepo, IDEs or other tooling may slow down when presented with a large solution file. Currently, ",(0,o.jsx)(n.code,{children:"nx-dotnet"})," does not assist in managing this issue, but there are a few easy steps to take that can help optimize your workflow. Which path you take will depend on both the tooling you use, and the pains that you are enountering."]}),"\n",(0,o.jsx)(n.p,{children:"Either of the two approaches listed below could be expanded on in the future, but currently are not in the scope of the nx-plugin."}),"\n",(0,o.jsx)(n.h3,{id:"separate-solution-files",children:"Separate solution files"}),"\n",(0,o.jsxs)(n.p,{children:["One option would be totally separated solution files for project graphs that are not connected. The main thing to be cautious with in an approach like this, is that if the dependency graph changes and the two subgraphs become connected it would be possible to make changes that break a project not currently visible to the IDE. For example, lets say you have 3 projects ",(0,o.jsx)(n.code,{children:"A"}),", ",(0,o.jsx)(n.code,{children:"B"}),", and ",(0,o.jsx)(n.code,{children:"Shared"}),". If ",(0,o.jsx)(n.code,{children:"A"})," and ",(0,o.jsx)(n.code,{children:"B"})," both depend on ",(0,o.jsx)(n.code,{children:"Shared"}),", and you have separate solutions each containing either ",(0,o.jsx)(n.code,{children:"A"})," or ",(0,o.jsx)(n.code,{children:"B"})," alongside the ",(0,o.jsx)(n.code,{children:"Shared"})," project, a developer could modify the code in ",(0,o.jsx)(n.code,{children:"Shared"})," and break the project that was not included in the opened solution file. As such, any solution that contained ",(0,o.jsx)(n.code,{children:"Shared"})," ",(0,o.jsx)(n.em,{children:"must"})," contain all projects that depend on it to maintain good DX."]}),"\n",(0,o.jsx)(n.h3,{id:"solution-filters",children:"Solution filters"}),"\n",(0,o.jsxs)(n.p,{children:["Some IDEs such as Visual Studio support solution filters. These filters would allow for all projects to be visible to the IDE, but can have some performance benefits. The caveats to using separate files can still exist though, but these could be easier to maintain in the long run. Here is a link to the ",(0,o.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/visualstudio/ide/filtered-solutions?view=vs-2022",children:"msdn docs for solution filters"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.RP)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},2247:(e,n,t)=>{t.d(n,{RP:()=>c});var o=t(4041);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var a=o.createContext({}),c=function(e){var n=o.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=c(t),p=r,f=h["".concat(a,".").concat(p)]||h[p]||d[p]||i;return t?o.createElement(f,s(s({ref:n},u),{},{components:t})):o.createElement(f,s({ref:n},u))}));u.displayName="MDXCreateElement"}}]);